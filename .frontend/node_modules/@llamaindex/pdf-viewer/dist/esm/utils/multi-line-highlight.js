import Fuse from 'fuse.js';
import { DocumentColorEnum, highlightColors } from '../constants/colors.js';
/*
 * This function works by breaking the doc up into
 * individual words, finding the longest contiguous sub-sequence
 * that matches the given textToHighlight, and directly
 * setting the background-color on the spans associated with the
 * longest contiguous sub-sequence.
 * TODO: I do wish it was easier to understand / cleaner
 */
export const multiHighlight = (textToHighlight, pageNumber, color = DocumentColorEnum.yellow) => {
    var _a;
    const highlightColor = highlightColors[color];
    const spans = document.querySelectorAll(`div[data-page-number='${pageNumber + 1}'] .react-pdf__Page__textContent.textLayer span`);
    const words = [];
    spans.forEach((span, spanIdx) => {
        const htmlSpan = span;
        const spanWords = htmlSpan.textContent || '';
        spanWords.split(' ').map((text, wordIdx) => {
            words.push({ text, spanIdx, wordIdx });
        });
    });
    let searchString = textToHighlight;
    searchString = searchString.replace(/\s{2,}/g, ' ');
    searchString = searchString.replace(/\t/g, ' ');
    searchString = searchString
        .toString()
        .trim()
        .replace(/(\r\n|\n|\r)/g, '');
    const searchWords = searchString.split(' ');
    const lenSearchString = searchWords.length;
    if (!lenSearchString) {
        return;
    }
    const firstWord = searchWords[0];
    if (!firstWord) {
        return;
    }
    const searchData = generateDirectSearchData(firstWord, words, lenSearchString);
    const options = {
        includeScore: true,
        threshold: 0.1, // Adjust this threshold according to your requirement.
        minMatchCharLength: 10, // You might want to increase this for sentences.
        shouldSort: true,
        findAllMatches: true,
        includeMatches: true,
        keys: ['text'], // This tells Fuse.js to search in the `text` property of the items in your list
    };
    // @ts-ignore
    const fuse = new Fuse(searchData, options);
    const result = fuse.search(searchString);
    if (result.length > 0) {
        const searchResult = (_a = result[0]) === null || _a === void 0 ? void 0 : _a.item;
        const startSpan = (searchResult === null || searchResult === void 0 ? void 0 : searchResult.startSpan) || 0;
        const endSpan = (searchResult === null || searchResult === void 0 ? void 0 : searchResult.endSpan) || 0;
        const startWordIdx = (searchResult === null || searchResult === void 0 ? void 0 : searchResult.startWordIdx) || 0;
        const endWordIdx = (searchResult === null || searchResult === void 0 ? void 0 : searchResult.endWordIdx) || 0;
        for (let i = startSpan; i < endSpan + 1; i++) {
            const spanToHighlight = spans[i];
            if (i == startSpan) {
                if (startWordIdx === 0) {
                    highlightHtmlElement(spanToHighlight, highlightColor);
                }
                else {
                    partialHighlight(startWordIdx, spanToHighlight, DIRECTION.START);
                }
            }
            else if (i == endSpan) {
                if (endWordIdx === 0) {
                    return;
                }
                else {
                    partialHighlight(endWordIdx, spanToHighlight, DIRECTION.END);
                }
            }
            else {
                highlightHtmlElement(spanToHighlight, highlightColor);
            }
        }
    }
    return true;
};
const HIGHLIGHT_CLASSNAME = 'opacity-40 saturate-[3] highlighted-by-llama ';
const highlightHtmlElement = (div, color) => {
    const text = div.textContent || '';
    const newSpan = document.createElement('span');
    newSpan.className = HIGHLIGHT_CLASSNAME + color;
    newSpan.innerText = text;
    div.innerText = '';
    div.appendChild(newSpan);
};
var DIRECTION;
(function (DIRECTION) {
    DIRECTION[DIRECTION["START"] = 0] = "START";
    DIRECTION[DIRECTION["END"] = 1] = "END";
})(DIRECTION || (DIRECTION = {}));
const partialHighlight = (idx, span, direction = DIRECTION.START) => {
    const text = span.textContent;
    if (!text) {
        return;
    }
    const test = text.split(' ')[idx - 1] || '';
    const substringToHighlight = test; // replace this with the actual substring
    // Remove existing content in the span
    span.textContent = '';
    // Split the text into pieces by the substring
    const parts = text.split(substringToHighlight);
    // For each piece, append it and the highlighted substring (except for the last piece)
    parts.forEach((part, index) => {
        if (direction === DIRECTION.START) {
            if (index == 0) {
                span.appendChild(document.createTextNode(part));
            }
            else {
                span.appendChild(document.createTextNode(test));
                const highlightSpan = document.createElement('span');
                highlightSpan.className = HIGHLIGHT_CLASSNAME;
                highlightSpan.textContent = part;
                span.appendChild(highlightSpan);
            }
        }
        if (direction === DIRECTION.END) {
            if (index == 0) {
                const highlightSpan = document.createElement('span');
                highlightSpan.className = HIGHLIGHT_CLASSNAME;
                highlightSpan.textContent = part;
                span.appendChild(highlightSpan);
                // TODO: this is wrong, because it causes a double copy paste issue.
                // But without it, the offset is incorrect.
                span.appendChild(document.createTextNode(part));
            }
            else {
                span.appendChild(document.createTextNode(test));
                span.appendChild(document.createTextNode(part));
            }
        }
    });
};
function generateDirectSearchData(startString, words, n) {
    var _a, _b, _c, _d, _e;
    const searchStrings = [];
    for (let i = 0; i <= words.length - n; i++) {
        if (((_a = words[i]) === null || _a === void 0 ? void 0 : _a.text) === startString) {
            // constructs sentence of length n
            const text = words.slice(i, i + n).reduce((acc, val) => acc + ' ' + val.text, '');
            const startSpan = ((_b = words[i]) === null || _b === void 0 ? void 0 : _b.spanIdx) || 0; // have to add these defaults because typescript is dumb
            const endSpan = ((_c = words[i + n]) === null || _c === void 0 ? void 0 : _c.spanIdx) || 0;
            const startWordIdx = ((_d = words[i]) === null || _d === void 0 ? void 0 : _d.wordIdx) || 0;
            const endWordIdx = ((_e = words[i + n]) === null || _e === void 0 ? void 0 : _e.wordIdx) || 0;
            searchStrings.push({
                text,
                startSpan,
                endSpan,
                startWordIdx,
                endWordIdx,
            });
        }
    }
    return searchStrings;
}
