var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { jsx as _jsx } from "react/jsx-runtime";
import { useWindowHeight, useWindowWidth } from '@wojtekmaj/react-hooks';
import debounce from 'lodash.debounce';
import React, { forwardRef, memo, useCallback, useEffect, useRef, useState } from 'react';
import { useInView } from 'react-intersection-observer';
import { Document, Page, pdfjs } from 'react-pdf';
import { VariableSizeList as List } from 'react-window';
import { multiHighlight } from '../utils/multi-line-highlight.js';
import { usePdfFocus } from '../hooks/usePdfFocus.js';
import { PDF_DISPLAY_DEFAULTS } from '../constants/constants.js';
const pdfjsOptions = pdfjs.GlobalWorkerOptions;
const pdfjsVersion = pdfjs.version;
pdfjsOptions.workerSrc =
    '//unpkg.com/pdfjs-dist@' + String(pdfjsVersion) + '/legacy/build/pdf.worker.min.mjs';
const { HORIZONTAL_GUTTER_SIZE_PX, OBSERVER_THRESHOLD_PERCENTAGE, PAGE_HEIGHT, PDF_HEADER_SIZE_PX, PDF_SIDEBAR_SIZE_PX, PDF_WIDTH_PERCENTAGE, VERTICAL_GUTTER_SIZE_PX, } = PDF_DISPLAY_DEFAULTS;
const PageRenderer = ({ file, pageNumber, style, scale, listWidth, setPageInView, }) => {
    var _a;
    const { pdfFocusState } = usePdfFocus();
    const [shouldCenter, setShouldCenter] = useState(false);
    const [isHighlighted, setIsHighlighted] = useState(false);
    // Get which page is in view from an intersection observer
    const { ref: inViewRef, inView } = useInView({
        threshold: OBSERVER_THRESHOLD_PERCENTAGE * Math.min(1 / scale, 1),
    });
    // Prevents black flickering, which is fixed in 7.1.2, but we must
    // use 6.2.2 because highlights are broken in 7.1.2 :/
    // https://github.com/wojtekmaj/react-pdf/issues/1340#issuecomment-1483869537
    const containerRef = useRef(null);
    // Use `useCallback` so we don't recreate the function on each render
    // Need to set two Refs, one for the intersection observer, one for the container
    const setRefs = useCallback((node) => {
        // Ref's from useRef needs to have the node assigned to `current`
        containerRef.current =
            node;
        // Callback refs, like the one from `useInView`, is a function that takes the node as an argument
        inViewRef(node);
    }, [inViewRef]);
    useEffect(() => {
        if (inView) {
            setPageInView(pageNumber);
        }
    }, [inView, pageNumber, setPageInView, inViewRef]);
    const hidePageCanvas = useCallback(() => {
        if (containerRef.current) {
            const canvas = containerRef.current.querySelector('canvas');
            if (canvas)
                canvas.style.visibility = 'hidden';
        }
    }, [containerRef]);
    const showPageCanvas = useCallback(() => {
        if (containerRef.current) {
            const canvas = containerRef.current.querySelector('canvas');
            if (canvas)
                canvas.style.visibility = 'visible';
        }
    }, [containerRef]);
    const onPageLoadSuccess = useCallback(() => {
        hidePageCanvas();
    }, [hidePageCanvas]);
    const onPageRenderError = useCallback(() => {
        showPageCanvas();
    }, [showPageCanvas]);
    const onPageRenderSuccess = useCallback((page) => {
        // console.log("triggering rerender for page", index);
        showPageCanvas();
        maybeHighlight();
        // react-pdf absolutely pins the pdf into the upper left corner
        // so when the scale changes and the width is smaller than the parent
        // container, we need to use flex box to center the pdf.
        //
        // why not always center the pdf? when this condition is not true,
        // display: flex breaks scrolling. not quite sure why.
        if (listWidth > page.width) {
            setShouldCenter(true);
        }
        else {
            setShouldCenter(false);
        }
    }, [showPageCanvas, listWidth]);
    const documentFocused = pdfFocusState.documentId === file.id;
    useEffect(() => {
        maybeHighlight();
    }, [documentFocused, inView]);
    const maybeHighlight = useCallback(debounce(() => {
        var _a;
        if (documentFocused &&
            ((_a = pdfFocusState.citation) === null || _a === void 0 ? void 0 : _a.pageNumber) === pageNumber + 1 &&
            !isHighlighted) {
            multiHighlight(pdfFocusState.citation.snippet, pageNumber, pdfFocusState.citation.color);
            setIsHighlighted(true);
        }
    }, 50), [(_a = pdfFocusState.citation) === null || _a === void 0 ? void 0 : _a.snippet, pageNumber, isHighlighted]);
    return (_jsx("div", { ref: setRefs, style: Object.assign(Object.assign({}, style), { 
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            padding: '10px', backgroundColor: 'WhiteSmoke', display: `${shouldCenter ? 'flex' : ''}`, justifyContent: 'center' }), children: _jsx(Page, { scale: scale, onRenderSuccess: onPageRenderSuccess, onLoadSuccess: onPageLoadSuccess, onRenderError: onPageRenderError, pageIndex: pageNumber, renderAnnotationLayer: true }) }, `${file.url}-${pageNumber}`));
};
// eslint-disable-next-line react/display-name
const VirtualizedPDF = forwardRef(({ file, scale, setIndex, setScaleFit, setNumPages }, ref) => {
    const windowWidth = useWindowWidth();
    const windowHeight = useWindowHeight();
    const height = (windowHeight || 0) - PDF_HEADER_SIZE_PX;
    const newWidthPx = PDF_WIDTH_PERCENTAGE * 0.01 * (windowWidth || 0) -
        PDF_SIDEBAR_SIZE_PX -
        HORIZONTAL_GUTTER_SIZE_PX;
    const [pdf, setPdf] = useState(null);
    const listRef = useRef(null);
    useEffect(() => {
        // Changing scale changes the measurement of the item, so we need to bust the cache, see:
        // https://github.com/bvaughn/react-window/issues/344#issuecomment-540583132
        if (listRef.current) {
            listRef.current.resetAfterIndex(0);
        }
    }, [scale]);
    function onDocumentLoadSuccess(nextPdf) {
        setPdf(nextPdf);
    }
    function getPageHeight() {
        const actualHeight = (PAGE_HEIGHT + VERTICAL_GUTTER_SIZE_PX) * scale;
        return actualHeight;
    }
    useEffect(() => {
        if (!pdf) {
            return;
        }
        function loadFirstPage() {
            return __awaiter(this, void 0, void 0, function* () {
                if (pdf) {
                    yield pdf
                        .getPage(1)
                        .then((page) => {
                        const pageViewport = page.getViewport({ scale: 1 });
                        const pageWidth = pageViewport.width;
                        const computedScaleFit = newWidthPx / pageWidth;
                        // set scale to fit to page
                        setScaleFit(computedScaleFit);
                    });
                }
            });
        }
        loadFirstPage().catch(() => console.log('page load error'));
        setNumPages(pdf.numPages);
    }, [pdf, setNumPages, setScaleFit, newWidthPx]);
    React.useImperativeHandle(ref, () => ({
        // This function can be called from the parent component
        scrollToPage: (page) => {
            onItemClick({ pageNumber: page });
        },
    }));
    const onItemClick = ({ pageNumber: itemPageNumber }) => {
        const fixedPosition = itemPageNumber * (PAGE_HEIGHT + VERTICAL_GUTTER_SIZE_PX) * scale;
        if (listRef.current) {
            listRef.current.scrollTo(fixedPosition);
        }
    };
    return (_jsx("div", { className: "pdfDocument", children: _jsx(Document, { onItemClick: onItemClick, file: file.url, onLoadSuccess: onDocumentLoadSuccess, loading: "Loading...", children: pdf ? (_jsx(List, { ref: listRef, width: newWidthPx + HORIZONTAL_GUTTER_SIZE_PX, height: height, itemCount: pdf.numPages, itemSize: getPageHeight, estimatedItemSize: (PAGE_HEIGHT + VERTICAL_GUTTER_SIZE_PX) * scale, children: ({ index, style }) => (_jsx(PageRenderer, { file: file, pageNumber: index, style: style, scale: scale, listWidth: newWidthPx, setPageInView: setIndex }, `page-${index}`)) })) : null }, file.url) }));
});
const MemoizedVirtualizedPDF = memo(VirtualizedPDF);
MemoizedVirtualizedPDF.displayName = 'VirtualizedPDF';
export default MemoizedVirtualizedPDF;
