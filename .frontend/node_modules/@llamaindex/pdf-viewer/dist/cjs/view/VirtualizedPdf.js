"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jsx_runtime_1 = require("react/jsx-runtime");
const react_hooks_1 = require("@wojtekmaj/react-hooks");
const lodash_debounce_1 = __importDefault(require("lodash.debounce"));
const react_1 = __importStar(require("react"));
const react_intersection_observer_1 = require("react-intersection-observer");
const react_pdf_1 = require("react-pdf");
const react_window_1 = require("react-window");
const multi_line_highlight_js_1 = require("../utils/multi-line-highlight.js");
const usePdfFocus_js_1 = require("../hooks/usePdfFocus.js");
const constants_js_1 = require("../constants/constants.js");
const pdfjsOptions = react_pdf_1.pdfjs.GlobalWorkerOptions;
const pdfjsVersion = react_pdf_1.pdfjs.version;
pdfjsOptions.workerSrc =
    '//unpkg.com/pdfjs-dist@' + String(pdfjsVersion) + '/legacy/build/pdf.worker.min.mjs';
const { HORIZONTAL_GUTTER_SIZE_PX, OBSERVER_THRESHOLD_PERCENTAGE, PAGE_HEIGHT, PDF_HEADER_SIZE_PX, PDF_SIDEBAR_SIZE_PX, PDF_WIDTH_PERCENTAGE, VERTICAL_GUTTER_SIZE_PX, } = constants_js_1.PDF_DISPLAY_DEFAULTS;
const PageRenderer = ({ file, pageNumber, style, scale, listWidth, setPageInView, }) => {
    var _a;
    const { pdfFocusState } = (0, usePdfFocus_js_1.usePdfFocus)();
    const [shouldCenter, setShouldCenter] = (0, react_1.useState)(false);
    const [isHighlighted, setIsHighlighted] = (0, react_1.useState)(false);
    // Get which page is in view from an intersection observer
    const { ref: inViewRef, inView } = (0, react_intersection_observer_1.useInView)({
        threshold: OBSERVER_THRESHOLD_PERCENTAGE * Math.min(1 / scale, 1),
    });
    // Prevents black flickering, which is fixed in 7.1.2, but we must
    // use 6.2.2 because highlights are broken in 7.1.2 :/
    // https://github.com/wojtekmaj/react-pdf/issues/1340#issuecomment-1483869537
    const containerRef = (0, react_1.useRef)(null);
    // Use `useCallback` so we don't recreate the function on each render
    // Need to set two Refs, one for the intersection observer, one for the container
    const setRefs = (0, react_1.useCallback)((node) => {
        // Ref's from useRef needs to have the node assigned to `current`
        containerRef.current =
            node;
        // Callback refs, like the one from `useInView`, is a function that takes the node as an argument
        inViewRef(node);
    }, [inViewRef]);
    (0, react_1.useEffect)(() => {
        if (inView) {
            setPageInView(pageNumber);
        }
    }, [inView, pageNumber, setPageInView, inViewRef]);
    const hidePageCanvas = (0, react_1.useCallback)(() => {
        if (containerRef.current) {
            const canvas = containerRef.current.querySelector('canvas');
            if (canvas)
                canvas.style.visibility = 'hidden';
        }
    }, [containerRef]);
    const showPageCanvas = (0, react_1.useCallback)(() => {
        if (containerRef.current) {
            const canvas = containerRef.current.querySelector('canvas');
            if (canvas)
                canvas.style.visibility = 'visible';
        }
    }, [containerRef]);
    const onPageLoadSuccess = (0, react_1.useCallback)(() => {
        hidePageCanvas();
    }, [hidePageCanvas]);
    const onPageRenderError = (0, react_1.useCallback)(() => {
        showPageCanvas();
    }, [showPageCanvas]);
    const onPageRenderSuccess = (0, react_1.useCallback)((page) => {
        // console.log("triggering rerender for page", index);
        showPageCanvas();
        maybeHighlight();
        // react-pdf absolutely pins the pdf into the upper left corner
        // so when the scale changes and the width is smaller than the parent
        // container, we need to use flex box to center the pdf.
        //
        // why not always center the pdf? when this condition is not true,
        // display: flex breaks scrolling. not quite sure why.
        if (listWidth > page.width) {
            setShouldCenter(true);
        }
        else {
            setShouldCenter(false);
        }
    }, [showPageCanvas, listWidth]);
    const documentFocused = pdfFocusState.documentId === file.id;
    (0, react_1.useEffect)(() => {
        maybeHighlight();
    }, [documentFocused, inView]);
    const maybeHighlight = (0, react_1.useCallback)((0, lodash_debounce_1.default)(() => {
        var _a;
        if (documentFocused &&
            ((_a = pdfFocusState.citation) === null || _a === void 0 ? void 0 : _a.pageNumber) === pageNumber + 1 &&
            !isHighlighted) {
            (0, multi_line_highlight_js_1.multiHighlight)(pdfFocusState.citation.snippet, pageNumber, pdfFocusState.citation.color);
            setIsHighlighted(true);
        }
    }, 50), [(_a = pdfFocusState.citation) === null || _a === void 0 ? void 0 : _a.snippet, pageNumber, isHighlighted]);
    return ((0, jsx_runtime_1.jsx)("div", { ref: setRefs, style: Object.assign(Object.assign({}, style), { 
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            padding: '10px', backgroundColor: 'WhiteSmoke', display: `${shouldCenter ? 'flex' : ''}`, justifyContent: 'center' }), children: (0, jsx_runtime_1.jsx)(react_pdf_1.Page, { scale: scale, onRenderSuccess: onPageRenderSuccess, onLoadSuccess: onPageLoadSuccess, onRenderError: onPageRenderError, pageIndex: pageNumber, renderAnnotationLayer: true }) }, `${file.url}-${pageNumber}`));
};
// eslint-disable-next-line react/display-name
const VirtualizedPDF = (0, react_1.forwardRef)(({ file, scale, setIndex, setScaleFit, setNumPages }, ref) => {
    const windowWidth = (0, react_hooks_1.useWindowWidth)();
    const windowHeight = (0, react_hooks_1.useWindowHeight)();
    const height = (windowHeight || 0) - PDF_HEADER_SIZE_PX;
    const newWidthPx = PDF_WIDTH_PERCENTAGE * 0.01 * (windowWidth || 0) -
        PDF_SIDEBAR_SIZE_PX -
        HORIZONTAL_GUTTER_SIZE_PX;
    const [pdf, setPdf] = (0, react_1.useState)(null);
    const listRef = (0, react_1.useRef)(null);
    (0, react_1.useEffect)(() => {
        // Changing scale changes the measurement of the item, so we need to bust the cache, see:
        // https://github.com/bvaughn/react-window/issues/344#issuecomment-540583132
        if (listRef.current) {
            listRef.current.resetAfterIndex(0);
        }
    }, [scale]);
    function onDocumentLoadSuccess(nextPdf) {
        setPdf(nextPdf);
    }
    function getPageHeight() {
        const actualHeight = (PAGE_HEIGHT + VERTICAL_GUTTER_SIZE_PX) * scale;
        return actualHeight;
    }
    (0, react_1.useEffect)(() => {
        if (!pdf) {
            return;
        }
        function loadFirstPage() {
            return __awaiter(this, void 0, void 0, function* () {
                if (pdf) {
                    yield pdf
                        .getPage(1)
                        .then((page) => {
                        const pageViewport = page.getViewport({ scale: 1 });
                        const pageWidth = pageViewport.width;
                        const computedScaleFit = newWidthPx / pageWidth;
                        // set scale to fit to page
                        setScaleFit(computedScaleFit);
                    });
                }
            });
        }
        loadFirstPage().catch(() => console.log('page load error'));
        setNumPages(pdf.numPages);
    }, [pdf, setNumPages, setScaleFit, newWidthPx]);
    react_1.default.useImperativeHandle(ref, () => ({
        // This function can be called from the parent component
        scrollToPage: (page) => {
            onItemClick({ pageNumber: page });
        },
    }));
    const onItemClick = ({ pageNumber: itemPageNumber }) => {
        const fixedPosition = itemPageNumber * (PAGE_HEIGHT + VERTICAL_GUTTER_SIZE_PX) * scale;
        if (listRef.current) {
            listRef.current.scrollTo(fixedPosition);
        }
    };
    return ((0, jsx_runtime_1.jsx)("div", { className: "pdfDocument", children: (0, jsx_runtime_1.jsx)(react_pdf_1.Document, { onItemClick: onItemClick, file: file.url, onLoadSuccess: onDocumentLoadSuccess, loading: "Loading...", children: pdf ? ((0, jsx_runtime_1.jsx)(react_window_1.VariableSizeList, { ref: listRef, width: newWidthPx + HORIZONTAL_GUTTER_SIZE_PX, height: height, itemCount: pdf.numPages, itemSize: getPageHeight, estimatedItemSize: (PAGE_HEIGHT + VERTICAL_GUTTER_SIZE_PX) * scale, children: ({ index, style }) => ((0, jsx_runtime_1.jsx)(PageRenderer, { file: file, pageNumber: index, style: style, scale: scale, listWidth: newWidthPx, setPageInView: setIndex }, `page-${index}`)) })) : null }, file.url) }));
});
const MemoizedVirtualizedPDF = (0, react_1.memo)(VirtualizedPDF);
MemoizedVirtualizedPDF.displayName = 'VirtualizedPDF';
exports.default = MemoizedVirtualizedPDF;
