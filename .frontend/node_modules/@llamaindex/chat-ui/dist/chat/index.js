var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/chat/annotation.ts
var MessageAnnotationType = /* @__PURE__ */ ((MessageAnnotationType2) => {
  MessageAnnotationType2["IMAGE"] = "image";
  MessageAnnotationType2["DOCUMENT_FILE"] = "document_file";
  MessageAnnotationType2["SOURCES"] = "sources";
  MessageAnnotationType2["EVENTS"] = "events";
  MessageAnnotationType2["SUGGESTED_QUESTIONS"] = "suggested_questions";
  MessageAnnotationType2["AGENT_EVENTS"] = "agent";
  return MessageAnnotationType2;
})(MessageAnnotationType || {});
var DOCUMENT_FILE_TYPES = [
  "csv",
  "pdf",
  "txt",
  "docx"
];
var NODE_SCORE_THRESHOLD = 0.25;
function getAnnotationData(annotations, type) {
  if (!(annotations == null ? void 0 : annotations.length)) return [];
  return annotations.filter((a) => a.type.toString() === type).map((a) => a.data);
}
function getSourceAnnotationData(annotations) {
  const data = getAnnotationData(
    annotations,
    "sources" /* SOURCES */
  );
  if (data.length > 0) {
    return [
      __spreadProps(__spreadValues({}, data[0]), {
        nodes: data[0].nodes ? preprocessSourceNodes(data[0].nodes) : []
      })
    ];
  }
  return data;
}
function preprocessSourceNodes(nodes) {
  const processedNodes = nodes.filter((node) => {
    var _a;
    return ((_a = node.score) != null ? _a : 1) > NODE_SCORE_THRESHOLD;
  }).filter((node) => node.url && node.url.trim() !== "").sort((a, b) => {
    var _a, _b;
    return ((_a = b.score) != null ? _a : 1) - ((_b = a.score) != null ? _b : 1);
  }).map((node) => {
    node.url = node.url.replace(/\/$/, "");
    return node;
  });
  return processedNodes;
}

// src/chat/chat-section.tsx
import { useState as useState2 } from "react";

// src/lib/utils.ts
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge";
function cn(...inputs) {
  return twMerge(clsx(inputs));
}

// src/chat/chat-input.tsx
import { createContext as createContext2, useContext as useContext2 } from "react";

// src/ui/button.tsx
import { Slot } from "@radix-ui/react-slot";
import { cva } from "class-variance-authority";
import * as React from "react";
import { jsx } from "react/jsx-runtime";
var buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
var Button = React.forwardRef(
  (_a, ref) => {
    var _b = _a, { className, variant, size, asChild = false } = _b, props = __objRest(_b, ["className", "variant", "size", "asChild"]);
    const Comp = asChild ? Slot : "button";
    return /* @__PURE__ */ jsx(
      Comp,
      __spreadValues({
        className: cn(buttonVariants({ variant, size, className })),
        ref
      }, props)
    );
  }
);
Button.displayName = "Button";

// src/ui/input.tsx
import * as React2 from "react";
import { jsx as jsx2 } from "react/jsx-runtime";
var Input = React2.forwardRef(
  (_a, ref) => {
    var _b = _a, { className, type } = _b, props = __objRest(_b, ["className", "type"]);
    return /* @__PURE__ */ jsx2(
      "input",
      __spreadValues({
        type,
        className: cn(
          "border-input bg-background ring-offset-background placeholder:text-muted-foreground focus-visible:ring-ring flex h-10 w-full rounded-md border px-3 py-2 text-sm file:border-0 file:bg-transparent file:text-sm file:font-medium focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        ),
        ref
      }, props)
    );
  }
);
Input.displayName = "Input";

// src/ui/textarea.tsx
import * as React3 from "react";
import { jsx as jsx3 } from "react/jsx-runtime";
var Textarea = React3.forwardRef(
  (_a, ref) => {
    var _b = _a, { className } = _b, props = __objRest(_b, ["className"]);
    return /* @__PURE__ */ jsx3(
      "textarea",
      __spreadValues({
        className: cn(
          "border-input bg-background ring-offset-background placeholder:text-muted-foreground focus-visible:ring-ring flex min-h-[80px] w-full rounded-md border px-3 py-2 text-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        ),
        ref
      }, props)
    );
  }
);
Textarea.displayName = "Textarea";

// src/chat/chat-input.tsx
import { FileUploader } from "../widgets/index.js";

// src/chat/chat.context.ts
import { createContext, useContext } from "react";
var chatContext = createContext(null);
var ChatProvider = chatContext.Provider;
var useChatUI = () => {
  const context = useContext(chatContext);
  if (!context) {
    throw new Error("useChatUI must be used within a ChatProvider");
  }
  return context;
};

// src/chat/chat-input.tsx
import { Fragment, jsx as jsx4, jsxs } from "react/jsx-runtime";
var ALLOWED_EXTENSIONS = ["png", "jpg", "jpeg", "csv", "pdf", "txt", "docx"];
var chatInputContext = createContext2(null);
var ChatInputProvider = chatInputContext.Provider;
var useChatInput = () => {
  const context = useContext2(chatInputContext);
  if (!context) {
    throw new Error("useChatInput must be used within a ChatInputProvider");
  }
  return context;
};
function ChatInput(props) {
  var _a;
  const { input, setInput, append, isLoading, requestData } = useChatUI();
  const isDisabled = isLoading || !input.trim();
  const submit = () => __async(this, null, function* () {
    var _a2;
    const newMessage = {
      role: "user",
      content: input,
      annotations: props.annotations
    };
    setInput("");
    (_a2 = props.resetUploadedFiles) == null ? void 0 : _a2.call(props);
    yield append(newMessage, { data: requestData });
  });
  const handleSubmit = (e) => __async(this, null, function* () {
    e.preventDefault();
    yield submit();
  });
  const handleKeyDown = (e) => __async(this, null, function* () {
    if (isDisabled) return;
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      yield submit();
    }
  });
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ jsx4(ChatInputForm, {});
  return /* @__PURE__ */ jsx4(ChatInputProvider, { value: { isDisabled, handleKeyDown, handleSubmit }, children: /* @__PURE__ */ jsx4(
    "div",
    {
      className: cn(
        "bg-background flex shrink-0 flex-col gap-4 p-4",
        props.className
      ),
      children
    }
  ) });
}
function ChatInputForm(props) {
  var _a;
  const { handleSubmit } = useChatInput();
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx4(ChatInputField, {}),
    /* @__PURE__ */ jsx4(ChatInputSubmit, {})
  ] });
  return /* @__PURE__ */ jsx4("form", { onSubmit: handleSubmit, className: cn(props.className, "flex gap-2"), children });
}
function ChatInputField(props) {
  var _a, _b, _c;
  const { input, setInput } = useChatUI();
  const { handleKeyDown } = useChatInput();
  const type = (_a = props.type) != null ? _a : "textarea";
  if (type === "input") {
    return /* @__PURE__ */ jsx4(
      Input,
      {
        name: "input",
        placeholder: (_b = props.placeholder) != null ? _b : "Type a message",
        className: cn(props.className, "min-h-0"),
        value: input,
        onChange: (e) => setInput(e.target.value)
      }
    );
  }
  return /* @__PURE__ */ jsx4(
    Textarea,
    {
      name: "input",
      placeholder: (_c = props.placeholder) != null ? _c : "Type a message",
      className: cn(props.className, "h-[40px] min-h-0 flex-1"),
      value: input,
      onChange: (e) => setInput(e.target.value),
      onKeyDown: handleKeyDown
    }
  );
}
function ChatInputUpload(props) {
  var _a, _b;
  const { requestData, setRequestData, isLoading } = useChatUI();
  const onFileUpload = (file) => __async(this, null, function* () {
    if (props.onUpload) {
      yield props.onUpload(file);
    } else {
      setRequestData(__spreadProps(__spreadValues({}, requestData || {}), { file }));
    }
  });
  return /* @__PURE__ */ jsx4(
    FileUploader,
    {
      onFileUpload,
      config: {
        disabled: isLoading,
        allowedExtensions: (_a = props.allowedExtensions) != null ? _a : ALLOWED_EXTENSIONS,
        multiple: (_b = props.multiple) != null ? _b : true
      }
    }
  );
}
function ChatInputSubmit(props) {
  var _a, _b;
  const { isDisabled } = useChatInput();
  return /* @__PURE__ */ jsx4(
    Button,
    {
      type: "submit",
      disabled: (_a = props.disabled) != null ? _a : isDisabled,
      className: cn(props.className),
      children: (_b = props.children) != null ? _b : "Send message"
    }
  );
}
ChatInput.Form = ChatInputForm;
ChatInput.Field = ChatInputField;
ChatInput.Upload = ChatInputUpload;
ChatInput.Submit = ChatInputSubmit;
var chat_input_default = ChatInput;

// src/chat/chat-messages.tsx
import { Loader2, PauseCircle, RefreshCw } from "lucide-react";
import { createContext as createContext4, useContext as useContext4, useEffect, useRef } from "react";

// src/chat/chat-message.tsx
import { Bot, Check, Copy, MessageCircle, User2 } from "lucide-react";
import { createContext as createContext3, Fragment as Fragment2, memo, useContext as useContext3, useMemo } from "react";

// src/hook/use-copy-to-clipboard.tsx
import * as React4 from "react";
function useCopyToClipboard({
  timeout = 2e3
}) {
  const [isCopied, setIsCopied] = React4.useState(false);
  const copyToClipboard = (value) => {
    var _a;
    if (typeof window === "undefined" || !((_a = navigator.clipboard) == null ? void 0 : _a.writeText)) {
      return;
    }
    if (!value) {
      return;
    }
    navigator.clipboard.writeText(value).then(() => {
      setIsCopied(true);
      setTimeout(() => {
        setIsCopied(false);
      }, timeout);
    });
  };
  return { isCopied, copyToClipboard };
}

// src/chat/chat-message.tsx
import { Markdown } from "../widgets/index.js";

// src/chat/chat-annotations.tsx
import {
  ChatAgentEvents,
  ChatEvents,
  ChatFiles,
  ChatImage,
  ChatSources,
  SuggestedQuestions
} from "../widgets/index.js";
import { jsx as jsx5 } from "react/jsx-runtime";
function EventAnnotations({
  message,
  showLoading
}) {
  const annotations = message.annotations;
  const eventData = annotations && annotations.length > 0 ? getAnnotationData(annotations, "events" /* EVENTS */) : null;
  if (!(eventData == null ? void 0 : eventData.length)) return null;
  return /* @__PURE__ */ jsx5(ChatEvents, { data: eventData, showLoading });
}
function AgentEventAnnotations({ message }) {
  const annotations = message.annotations;
  const agentEventData = annotations && annotations.length > 0 ? getAnnotationData(
    annotations,
    "agent" /* AGENT_EVENTS */
  ) : null;
  if (!(agentEventData == null ? void 0 : agentEventData.length)) return null;
  return /* @__PURE__ */ jsx5(
    ChatAgentEvents,
    {
      data: agentEventData,
      isFinished: Boolean(message.content)
    }
  );
}
function ImageAnnotations({ message }) {
  const annotations = message.annotations;
  const imageData = annotations && annotations.length > 0 ? getAnnotationData(annotations, "image") : null;
  if (!imageData) return null;
  return imageData[0] ? /* @__PURE__ */ jsx5(ChatImage, { data: imageData[0] }) : null;
}
function DocumentFileAnnotations({ message }) {
  const annotations = message.annotations;
  const contentFileData = annotations && annotations.length > 0 ? getAnnotationData(
    annotations,
    "document_file" /* DOCUMENT_FILE */
  ) : null;
  if (!contentFileData) return null;
  return contentFileData[0] ? /* @__PURE__ */ jsx5(ChatFiles, { data: contentFileData[0] }) : null;
}
function SourceAnnotations({ message }) {
  const annotations = message.annotations;
  const sourceData = annotations && annotations.length > 0 ? getSourceAnnotationData(annotations) : null;
  if (!sourceData) return null;
  return sourceData[0] ? /* @__PURE__ */ jsx5(ChatSources, { data: sourceData[0] }) : null;
}
function SuggestedQuestionsAnnotations({
  message,
  append
}) {
  const annotations = message.annotations;
  const suggestedQuestionsData = annotations && annotations.length > 0 ? getAnnotationData(
    annotations,
    "suggested_questions" /* SUGGESTED_QUESTIONS */
  ) : null;
  if (!(suggestedQuestionsData == null ? void 0 : suggestedQuestionsData[0])) return null;
  return /* @__PURE__ */ jsx5(SuggestedQuestions, { questions: suggestedQuestionsData[0], append });
}

// src/chat/chat-message.tsx
import { Fragment as Fragment3, jsx as jsx6, jsxs as jsxs2 } from "react/jsx-runtime";
var ContentPosition = /* @__PURE__ */ ((ContentPosition2) => {
  ContentPosition2[ContentPosition2["TOP"] = -9999] = "TOP";
  ContentPosition2[ContentPosition2["CHAT_EVENTS"] = 0] = "CHAT_EVENTS";
  ContentPosition2[ContentPosition2["AFTER_EVENTS"] = 1] = "AFTER_EVENTS";
  ContentPosition2[ContentPosition2["CHAT_AGENT_EVENTS"] = 2] = "CHAT_AGENT_EVENTS";
  ContentPosition2[ContentPosition2["AFTER_AGENT_EVENTS"] = 3] = "AFTER_AGENT_EVENTS";
  ContentPosition2[ContentPosition2["CHAT_IMAGE"] = 4] = "CHAT_IMAGE";
  ContentPosition2[ContentPosition2["AFTER_IMAGE"] = 5] = "AFTER_IMAGE";
  ContentPosition2[ContentPosition2["BEFORE_MARKDOWN"] = 6] = "BEFORE_MARKDOWN";
  ContentPosition2[ContentPosition2["MARKDOWN"] = 7] = "MARKDOWN";
  ContentPosition2[ContentPosition2["AFTER_MARKDOWN"] = 8] = "AFTER_MARKDOWN";
  ContentPosition2[ContentPosition2["CHAT_DOCUMENT_FILES"] = 9] = "CHAT_DOCUMENT_FILES";
  ContentPosition2[ContentPosition2["AFTER_DOCUMENT_FILES"] = 10] = "AFTER_DOCUMENT_FILES";
  ContentPosition2[ContentPosition2["CHAT_SOURCES"] = 11] = "CHAT_SOURCES";
  ContentPosition2[ContentPosition2["AFTER_SOURCES"] = 12] = "AFTER_SOURCES";
  ContentPosition2[ContentPosition2["SUGGESTED_QUESTIONS"] = 13] = "SUGGESTED_QUESTIONS";
  ContentPosition2[ContentPosition2["AFTER_SUGGESTED_QUESTIONS"] = 14] = "AFTER_SUGGESTED_QUESTIONS";
  ContentPosition2[ContentPosition2["BOTTOM"] = 9999] = "BOTTOM";
  return ContentPosition2;
})(ContentPosition || {});
var chatMessageContext = createContext3(null);
var ChatMessageProvider = chatMessageContext.Provider;
var useChatMessage = () => {
  const context = useContext3(chatMessageContext);
  if (!context)
    throw new Error("useChatMessage must be used within a ChatMessageProvider");
  return context;
};
function ChatMessage(props) {
  var _a;
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ jsxs2(Fragment3, { children: [
    /* @__PURE__ */ jsx6(ChatMessageAvatar, {}),
    /* @__PURE__ */ jsx6(ChatMessageContent, { isLoading: props.isLoading, append: props.append }),
    /* @__PURE__ */ jsx6(ChatMessageActions, {})
  ] });
  return /* @__PURE__ */ jsx6(
    ChatMessageProvider,
    {
      value: { message: props.message, isLast: props.isLast },
      children: /* @__PURE__ */ jsx6("div", { className: cn("group flex gap-4 p-3", props.className), children })
    }
  );
}
function ChatMessageAvatar(props) {
  var _a, _b;
  const { message } = useChatMessage();
  const roleIconMap = {
    user: /* @__PURE__ */ jsx6(User2, { className: "h-4 w-4" }),
    assistant: /* @__PURE__ */ jsx6(Bot, { className: "h-4 w-4" })
  };
  const children = (_b = (_a = props.children) != null ? _a : roleIconMap[message.role]) != null ? _b : /* @__PURE__ */ jsx6(MessageCircle, { className: "h-4 w-4" });
  return /* @__PURE__ */ jsx6("div", { className: "bg-background flex h-8 w-8 shrink-0 select-none items-center justify-center border", children });
}
function ChatMessageContent(props) {
  var _a, _b;
  const { message: defaultMessage, isLast } = useChatMessage();
  const message = (_a = props.message) != null ? _a : defaultMessage;
  const annotations = message.annotations;
  const contents = useMemo(() => {
    var _a2, _b2;
    const displayMap = __spreadValues({
      [0 /* CHAT_EVENTS */]: /* @__PURE__ */ jsx6(
        EventAnnotations,
        {
          message,
          showLoading: (_a2 = isLast && props.isLoading) != null ? _a2 : false
        }
      ),
      [2 /* CHAT_AGENT_EVENTS */]: /* @__PURE__ */ jsx6(AgentEventAnnotations, { message }),
      [4 /* CHAT_IMAGE */]: /* @__PURE__ */ jsx6(ImageAnnotations, { message }),
      [7 /* MARKDOWN */]: /* @__PURE__ */ jsx6(
        Markdown,
        {
          content: message.content,
          sources: annotations ? getSourceAnnotationData(annotations)[0] : void 0
        }
      ),
      [9 /* CHAT_DOCUMENT_FILES */]: /* @__PURE__ */ jsx6(DocumentFileAnnotations, { message }),
      [11 /* CHAT_SOURCES */]: /* @__PURE__ */ jsx6(SourceAnnotations, { message })
    }, isLast && props.append && {
      // show suggested questions only on the last message
      [13 /* SUGGESTED_QUESTIONS */]: /* @__PURE__ */ jsx6(
        SuggestedQuestionsAnnotations,
        {
          message,
          append: props.append
        }
      )
    });
    (_b2 = props.content) == null ? void 0 : _b2.forEach((content) => {
      displayMap[content.position] = content.component;
    });
    return Object.entries(displayMap).map(([position, component]) => ({
      position: parseInt(position),
      component
    }));
  }, [
    annotations,
    isLast,
    message,
    props.append,
    props.content,
    props.isLoading
  ]);
  const children = (_b = props.children) != null ? _b : /* @__PURE__ */ jsx6(Fragment3, { children: contents.sort((a, b) => a.position - b.position).map((content, index) => /* @__PURE__ */ jsx6(Fragment2, { children: content.component }, index)) });
  return /* @__PURE__ */ jsx6("div", { className: cn("flex min-w-0 flex-1 flex-col gap-4", props.className), children });
}
function ChatMessageActions(props) {
  var _a;
  const { isCopied, copyToClipboard } = useCopyToClipboard({ timeout: 2e3 });
  const { message } = useChatMessage();
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ jsx6(
    Button,
    {
      onClick: () => copyToClipboard(message.content),
      size: "icon",
      variant: "ghost",
      className: "h-8 w-8",
      children: isCopied ? /* @__PURE__ */ jsx6(Check, { className: "h-4 w-4" }) : /* @__PURE__ */ jsx6(Copy, { className: "h-4 w-4" })
    }
  );
  return /* @__PURE__ */ jsx6(
    "div",
    {
      className: cn(
        "flex shrink-0 flex-col gap-2 opacity-0 group-hover:opacity-100",
        props.className
      ),
      children
    }
  );
}
var PrimiviteChatMessage = memo(ChatMessage, (prevProps, nextProps) => {
  return !nextProps.isLast && prevProps.isLast === nextProps.isLast && prevProps.message === nextProps.message;
});
PrimiviteChatMessage.Avatar = ChatMessageAvatar;
PrimiviteChatMessage.Content = ChatMessageContent;
PrimiviteChatMessage.Actions = ChatMessageActions;
var chat_message_default = PrimiviteChatMessage;

// src/chat/chat-messages.tsx
import { Fragment as Fragment4, jsx as jsx7, jsxs as jsxs3 } from "react/jsx-runtime";
var chatMessagesContext = createContext4(null);
var ChatMessagesProvider = chatMessagesContext.Provider;
var useChatMessages = () => {
  const context = useContext4(chatMessagesContext);
  if (!context) {
    throw new Error(
      "useChatMessages must be used within a ChatMessagesProvider"
    );
  }
  return context;
};
function ChatMessages(props) {
  var _a;
  const { messages, reload, stop, isLoading } = useChatUI();
  const messageLength = messages.length;
  const lastMessage = messages[messageLength - 1];
  const isLastMessageFromAssistant = messageLength > 0 && (lastMessage == null ? void 0 : lastMessage.role) !== "user";
  const showReload = reload && !isLoading && isLastMessageFromAssistant;
  const showStop = stop && isLoading;
  const isPending = isLoading && !isLastMessageFromAssistant;
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ jsxs3(Fragment4, { children: [
    /* @__PURE__ */ jsx7(ChatMessagesList, {}),
    /* @__PURE__ */ jsx7(ChatActions, {})
  ] });
  return /* @__PURE__ */ jsx7(
    ChatMessagesProvider,
    {
      value: { isPending, showReload, showStop, lastMessage, messageLength },
      children: /* @__PURE__ */ jsx7(
        "div",
        {
          className: cn(
            "bg-background relative flex min-h-0 flex-1 flex-col space-y-6 p-4",
            props.className
          ),
          children
        }
      )
    }
  );
}
function ChatMessagesList(props) {
  var _a;
  const scrollableChatContainerRef = useRef(null);
  const { messages, isLoading, append } = useChatUI();
  const { lastMessage, messageLength } = useChatMessages();
  const scrollToBottom = () => {
    if (scrollableChatContainerRef.current) {
      scrollableChatContainerRef.current.scrollTop = scrollableChatContainerRef.current.scrollHeight;
    }
  };
  useEffect(() => {
    scrollToBottom();
  }, [messageLength, lastMessage]);
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ jsxs3(Fragment4, { children: [
    messages.map((message, index) => {
      return /* @__PURE__ */ jsx7(
        chat_message_default,
        {
          message,
          isLast: index === messageLength - 1,
          isLoading,
          append
        },
        index
      );
    }),
    /* @__PURE__ */ jsx7(ChatMessagesLoading, {})
  ] });
  return /* @__PURE__ */ jsx7(
    "div",
    {
      className: cn(
        "flex min-h-0 flex-1 flex-col gap-5 overflow-auto",
        props.className
      ),
      ref: scrollableChatContainerRef,
      children
    }
  );
}
function ChatMessagesLoading(props) {
  var _a;
  const { isPending } = useChatMessages();
  if (!isPending) return null;
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ jsx7(Loader2, { className: "h-4 w-4 animate-spin" });
  return /* @__PURE__ */ jsx7(
    "div",
    {
      className: cn("flex items-center justify-center pt-4", props.className),
      children
    }
  );
}
function ChatActions(props) {
  var _a;
  const { reload, stop, requestData } = useChatUI();
  const { showReload, showStop } = useChatMessages();
  if (!showStop && !showReload) return null;
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ jsxs3(Fragment4, { children: [
    showStop && /* @__PURE__ */ jsxs3(Button, { variant: "outline", size: "sm", onClick: stop, children: [
      /* @__PURE__ */ jsx7(PauseCircle, { className: "mr-2 h-4 w-4" }),
      "Stop generating"
    ] }),
    showReload && /* @__PURE__ */ jsxs3(
      Button,
      {
        variant: "outline",
        size: "sm",
        onClick: () => reload == null ? void 0 : reload({ data: requestData }),
        children: [
          /* @__PURE__ */ jsx7(RefreshCw, { className: "mr-2 h-4 w-4" }),
          "Regenerate"
        ]
      }
    )
  ] });
  return /* @__PURE__ */ jsx7("div", { className: cn("flex justify-end gap-4", props.className), children });
}
ChatMessages.List = ChatMessagesList;
ChatMessages.Loading = ChatMessagesLoading;
ChatMessages.Actions = ChatActions;
var chat_messages_default = ChatMessages;

// src/chat/chat-section.tsx
import { Fragment as Fragment5, jsx as jsx8, jsxs as jsxs4 } from "react/jsx-runtime";
function ChatSection(props) {
  var _a;
  const { handler, className } = props;
  const [requestData, setRequestData] = useState2();
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ jsxs4(Fragment5, { children: [
    /* @__PURE__ */ jsx8(chat_messages_default, {}),
    /* @__PURE__ */ jsx8(chat_input_default, {})
  ] });
  return /* @__PURE__ */ jsx8(ChatProvider, { value: __spreadProps(__spreadValues({}, handler), { requestData, setRequestData }), children: /* @__PURE__ */ jsx8("div", { className: cn("flex flex-col gap-4", className), children }) });
}

// src/hook/use-file.tsx
import { useState as useState3 } from "react";
var docMineTypeMap = {
  "text/csv": "csv",
  "application/pdf": "pdf",
  "text/plain": "txt",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "docx"
};
function useFile({ uploadAPI }) {
  const [imageUrl, setImageUrl] = useState3(null);
  const [files, setFiles] = useState3([]);
  const addDoc = (file) => {
    const existedFile = files.find((f) => f.id === file.id);
    if (!existedFile) {
      setFiles((prev) => [...prev, file]);
      return true;
    }
    return false;
  };
  const removeDoc = (file) => {
    setFiles((prev) => prev.filter((f) => f.id !== file.id));
  };
  const reset = () => {
    imageUrl && setImageUrl(null);
    files.length && setFiles([]);
  };
  const uploadContent = (_0, ..._1) => __async(this, [_0, ..._1], function* (file, requestParams = {}) {
    const base64 = yield readContent({ file, asUrl: true });
    const response = yield fetch(uploadAPI, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(__spreadProps(__spreadValues({}, requestParams), {
        base64,
        name: file.name
      }))
    });
    if (!response.ok) throw new Error("Failed to upload document.");
    return yield response.json();
  });
  const getAnnotations = () => {
    const annotations = [];
    if (imageUrl) {
      annotations.push({
        type: "image",
        data: { url: imageUrl }
      });
    }
    if (files.length > 0) {
      annotations.push({
        type: "document_file",
        data: { files }
      });
    }
    return annotations;
  };
  const readContent = (input) => __async(this, null, function* () {
    const { file, asUrl } = input;
    const content = yield new Promise((resolve, reject) => {
      const reader = new FileReader();
      if (asUrl) {
        reader.readAsDataURL(file);
      } else {
        reader.readAsText(file);
      }
      reader.onload = () => resolve(reader.result);
      reader.onerror = (error) => reject(error);
    });
    return content;
  });
  const uploadFile = (_0, ..._1) => __async(this, [_0, ..._1], function* (file, requestParams = {}) {
    if (file.type.startsWith("image/")) {
      const base64 = yield readContent({ file, asUrl: true });
      return setImageUrl(base64);
    }
    const filetype = docMineTypeMap[file.type];
    if (!filetype) throw new Error("Unsupported document type.");
    const newDoc = yield uploadContent(file, requestParams);
    return addDoc(newDoc);
  });
  return {
    imageUrl,
    setImageUrl,
    files,
    removeDoc,
    reset,
    getAnnotations,
    uploadFile
  };
}
export {
  chat_input_default as ChatInput,
  chat_message_default as ChatMessage,
  chat_messages_default as ChatMessages,
  ChatSection,
  ContentPosition,
  DOCUMENT_FILE_TYPES,
  MessageAnnotationType,
  getAnnotationData,
  getSourceAnnotationData,
  useChatInput,
  useChatMessage,
  useChatMessages,
  useChatUI,
  useFile
};
//# sourceMappingURL=index.js.map