"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.tsx
var src_exports = {};
__export(src_exports, {
  ChatInput: () => chat_input_default,
  ChatMessage: () => chat_message_default,
  ChatMessages: () => chat_messages_default,
  ChatSection: () => ChatSection,
  ContentPosition: () => ContentPosition,
  DOCUMENT_FILE_TYPES: () => DOCUMENT_FILE_TYPES,
  MessageAnnotationType: () => MessageAnnotationType,
  getAnnotationData: () => getAnnotationData,
  getSourceAnnotationData: () => getSourceAnnotationData,
  useChatInput: () => useChatInput,
  useChatMessage: () => useChatMessage,
  useChatMessages: () => useChatMessages,
  useChatUI: () => useChatUI,
  useFile: () => useFile
});
module.exports = __toCommonJS(src_exports);

// src/chat/annotation.ts
var MessageAnnotationType = /* @__PURE__ */ ((MessageAnnotationType2) => {
  MessageAnnotationType2["IMAGE"] = "image";
  MessageAnnotationType2["DOCUMENT_FILE"] = "document_file";
  MessageAnnotationType2["SOURCES"] = "sources";
  MessageAnnotationType2["EVENTS"] = "events";
  MessageAnnotationType2["SUGGESTED_QUESTIONS"] = "suggested_questions";
  MessageAnnotationType2["AGENT_EVENTS"] = "agent";
  return MessageAnnotationType2;
})(MessageAnnotationType || {});
var DOCUMENT_FILE_TYPES = [
  "csv",
  "pdf",
  "txt",
  "docx"
];
var NODE_SCORE_THRESHOLD = 0.25;
function getAnnotationData(annotations, type) {
  if (!(annotations == null ? void 0 : annotations.length)) return [];
  return annotations.filter((a) => a.type.toString() === type).map((a) => a.data);
}
function getSourceAnnotationData(annotations) {
  const data = getAnnotationData(
    annotations,
    "sources" /* SOURCES */
  );
  if (data.length > 0) {
    return [
      __spreadProps(__spreadValues({}, data[0]), {
        nodes: data[0].nodes ? preprocessSourceNodes(data[0].nodes) : []
      })
    ];
  }
  return data;
}
function preprocessSourceNodes(nodes) {
  const processedNodes = nodes.filter((node) => {
    var _a;
    return ((_a = node.score) != null ? _a : 1) > NODE_SCORE_THRESHOLD;
  }).filter((node) => node.url && node.url.trim() !== "").sort((a, b) => {
    var _a, _b;
    return ((_a = b.score) != null ? _a : 1) - ((_b = a.score) != null ? _b : 1);
  }).map((node) => {
    node.url = node.url.replace(/\/$/, "");
    return node;
  });
  return processedNodes;
}

// src/chat/chat-section.tsx
var import_react5 = require("react");

// src/lib/utils.ts
var import_clsx = require("clsx");
var import_tailwind_merge = require("tailwind-merge");
function cn(...inputs) {
  return (0, import_tailwind_merge.twMerge)((0, import_clsx.clsx)(inputs));
}

// src/chat/chat-input.tsx
var import_react2 = require("react");

// src/ui/button.tsx
var import_react_slot = require("@radix-ui/react-slot");
var import_class_variance_authority = require("class-variance-authority");
var React = __toESM(require("react"), 1);
var import_jsx_runtime = require("react/jsx-runtime");
var buttonVariants = (0, import_class_variance_authority.cva)(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
var Button = React.forwardRef(
  (_a, ref) => {
    var _b = _a, { className, variant, size, asChild = false } = _b, props = __objRest(_b, ["className", "variant", "size", "asChild"]);
    const Comp = asChild ? import_react_slot.Slot : "button";
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      Comp,
      __spreadValues({
        className: cn(buttonVariants({ variant, size, className })),
        ref
      }, props)
    );
  }
);
Button.displayName = "Button";

// src/ui/input.tsx
var React2 = __toESM(require("react"), 1);
var import_jsx_runtime2 = require("react/jsx-runtime");
var Input = React2.forwardRef(
  (_a, ref) => {
    var _b = _a, { className, type } = _b, props = __objRest(_b, ["className", "type"]);
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
      "input",
      __spreadValues({
        type,
        className: cn(
          "border-input bg-background ring-offset-background placeholder:text-muted-foreground focus-visible:ring-ring flex h-10 w-full rounded-md border px-3 py-2 text-sm file:border-0 file:bg-transparent file:text-sm file:font-medium focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        ),
        ref
      }, props)
    );
  }
);
Input.displayName = "Input";

// src/ui/textarea.tsx
var React3 = __toESM(require("react"), 1);
var import_jsx_runtime3 = require("react/jsx-runtime");
var Textarea = React3.forwardRef(
  (_a, ref) => {
    var _b = _a, { className } = _b, props = __objRest(_b, ["className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      "textarea",
      __spreadValues({
        className: cn(
          "border-input bg-background ring-offset-background placeholder:text-muted-foreground focus-visible:ring-ring flex min-h-[80px] w-full rounded-md border px-3 py-2 text-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        ),
        ref
      }, props)
    );
  }
);
Textarea.displayName = "Textarea";

// src/chat/chat-input.tsx
var import_widgets = require("../widgets/index.js");

// src/chat/chat.context.ts
var import_react = require("react");
var chatContext = (0, import_react.createContext)(null);
var ChatProvider = chatContext.Provider;
var useChatUI = () => {
  const context = (0, import_react.useContext)(chatContext);
  if (!context) {
    throw new Error("useChatUI must be used within a ChatProvider");
  }
  return context;
};

// src/chat/chat-input.tsx
var import_jsx_runtime4 = require("react/jsx-runtime");
var ALLOWED_EXTENSIONS = ["png", "jpg", "jpeg", "csv", "pdf", "txt", "docx"];
var chatInputContext = (0, import_react2.createContext)(null);
var ChatInputProvider = chatInputContext.Provider;
var useChatInput = () => {
  const context = (0, import_react2.useContext)(chatInputContext);
  if (!context) {
    throw new Error("useChatInput must be used within a ChatInputProvider");
  }
  return context;
};
function ChatInput(props) {
  var _a;
  const { input, setInput, append, isLoading, requestData } = useChatUI();
  const isDisabled = isLoading || !input.trim();
  const submit = () => __async(this, null, function* () {
    var _a2;
    const newMessage = {
      role: "user",
      content: input,
      annotations: props.annotations
    };
    setInput("");
    (_a2 = props.resetUploadedFiles) == null ? void 0 : _a2.call(props);
    yield append(newMessage, { data: requestData });
  });
  const handleSubmit = (e) => __async(this, null, function* () {
    e.preventDefault();
    yield submit();
  });
  const handleKeyDown = (e) => __async(this, null, function* () {
    if (isDisabled) return;
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      yield submit();
    }
  });
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ChatInputForm, {});
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ChatInputProvider, { value: { isDisabled, handleKeyDown, handleSubmit }, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
    "div",
    {
      className: cn(
        "bg-background flex shrink-0 flex-col gap-4 p-4",
        props.className
      ),
      children
    }
  ) });
}
function ChatInputForm(props) {
  var _a;
  const { handleSubmit } = useChatInput();
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ChatInputField, {}),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ChatInputSubmit, {})
  ] });
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("form", { onSubmit: handleSubmit, className: cn(props.className, "flex gap-2"), children });
}
function ChatInputField(props) {
  var _a, _b, _c;
  const { input, setInput } = useChatUI();
  const { handleKeyDown } = useChatInput();
  const type = (_a = props.type) != null ? _a : "textarea";
  if (type === "input") {
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
      Input,
      {
        name: "input",
        placeholder: (_b = props.placeholder) != null ? _b : "Type a message",
        className: cn(props.className, "min-h-0"),
        value: input,
        onChange: (e) => setInput(e.target.value)
      }
    );
  }
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
    Textarea,
    {
      name: "input",
      placeholder: (_c = props.placeholder) != null ? _c : "Type a message",
      className: cn(props.className, "h-[40px] min-h-0 flex-1"),
      value: input,
      onChange: (e) => setInput(e.target.value),
      onKeyDown: handleKeyDown
    }
  );
}
function ChatInputUpload(props) {
  var _a, _b;
  const { requestData, setRequestData, isLoading } = useChatUI();
  const onFileUpload = (file) => __async(this, null, function* () {
    if (props.onUpload) {
      yield props.onUpload(file);
    } else {
      setRequestData(__spreadProps(__spreadValues({}, requestData || {}), { file }));
    }
  });
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
    import_widgets.FileUploader,
    {
      onFileUpload,
      config: {
        disabled: isLoading,
        allowedExtensions: (_a = props.allowedExtensions) != null ? _a : ALLOWED_EXTENSIONS,
        multiple: (_b = props.multiple) != null ? _b : true
      }
    }
  );
}
function ChatInputSubmit(props) {
  var _a, _b;
  const { isDisabled } = useChatInput();
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
    Button,
    {
      type: "submit",
      disabled: (_a = props.disabled) != null ? _a : isDisabled,
      className: cn(props.className),
      children: (_b = props.children) != null ? _b : "Send message"
    }
  );
}
ChatInput.Form = ChatInputForm;
ChatInput.Field = ChatInputField;
ChatInput.Upload = ChatInputUpload;
ChatInput.Submit = ChatInputSubmit;
var chat_input_default = ChatInput;

// src/chat/chat-messages.tsx
var import_lucide_react2 = require("lucide-react");
var import_react4 = require("react");

// src/chat/chat-message.tsx
var import_lucide_react = require("lucide-react");
var import_react3 = require("react");

// src/hook/use-copy-to-clipboard.tsx
var React4 = __toESM(require("react"), 1);
function useCopyToClipboard({
  timeout = 2e3
}) {
  const [isCopied, setIsCopied] = React4.useState(false);
  const copyToClipboard = (value) => {
    var _a;
    if (typeof window === "undefined" || !((_a = navigator.clipboard) == null ? void 0 : _a.writeText)) {
      return;
    }
    if (!value) {
      return;
    }
    navigator.clipboard.writeText(value).then(() => {
      setIsCopied(true);
      setTimeout(() => {
        setIsCopied(false);
      }, timeout);
    });
  };
  return { isCopied, copyToClipboard };
}

// src/chat/chat-message.tsx
var import_widgets3 = require("../widgets/index.js");

// src/chat/chat-annotations.tsx
var import_widgets2 = require("../widgets/index.js");
var import_jsx_runtime5 = require("react/jsx-runtime");
function EventAnnotations({
  message,
  showLoading
}) {
  const annotations = message.annotations;
  const eventData = annotations && annotations.length > 0 ? getAnnotationData(annotations, "events" /* EVENTS */) : null;
  if (!(eventData == null ? void 0 : eventData.length)) return null;
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_widgets2.ChatEvents, { data: eventData, showLoading });
}
function AgentEventAnnotations({ message }) {
  const annotations = message.annotations;
  const agentEventData = annotations && annotations.length > 0 ? getAnnotationData(
    annotations,
    "agent" /* AGENT_EVENTS */
  ) : null;
  if (!(agentEventData == null ? void 0 : agentEventData.length)) return null;
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    import_widgets2.ChatAgentEvents,
    {
      data: agentEventData,
      isFinished: Boolean(message.content)
    }
  );
}
function ImageAnnotations({ message }) {
  const annotations = message.annotations;
  const imageData = annotations && annotations.length > 0 ? getAnnotationData(annotations, "image") : null;
  if (!imageData) return null;
  return imageData[0] ? /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_widgets2.ChatImage, { data: imageData[0] }) : null;
}
function DocumentFileAnnotations({ message }) {
  const annotations = message.annotations;
  const contentFileData = annotations && annotations.length > 0 ? getAnnotationData(
    annotations,
    "document_file" /* DOCUMENT_FILE */
  ) : null;
  if (!contentFileData) return null;
  return contentFileData[0] ? /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_widgets2.ChatFiles, { data: contentFileData[0] }) : null;
}
function SourceAnnotations({ message }) {
  const annotations = message.annotations;
  const sourceData = annotations && annotations.length > 0 ? getSourceAnnotationData(annotations) : null;
  if (!sourceData) return null;
  return sourceData[0] ? /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_widgets2.ChatSources, { data: sourceData[0] }) : null;
}
function SuggestedQuestionsAnnotations({
  message,
  append
}) {
  const annotations = message.annotations;
  const suggestedQuestionsData = annotations && annotations.length > 0 ? getAnnotationData(
    annotations,
    "suggested_questions" /* SUGGESTED_QUESTIONS */
  ) : null;
  if (!(suggestedQuestionsData == null ? void 0 : suggestedQuestionsData[0])) return null;
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_widgets2.SuggestedQuestions, { questions: suggestedQuestionsData[0], append });
}

// src/chat/chat-message.tsx
var import_jsx_runtime6 = require("react/jsx-runtime");
var ContentPosition = /* @__PURE__ */ ((ContentPosition2) => {
  ContentPosition2[ContentPosition2["TOP"] = -9999] = "TOP";
  ContentPosition2[ContentPosition2["CHAT_EVENTS"] = 0] = "CHAT_EVENTS";
  ContentPosition2[ContentPosition2["AFTER_EVENTS"] = 1] = "AFTER_EVENTS";
  ContentPosition2[ContentPosition2["CHAT_AGENT_EVENTS"] = 2] = "CHAT_AGENT_EVENTS";
  ContentPosition2[ContentPosition2["AFTER_AGENT_EVENTS"] = 3] = "AFTER_AGENT_EVENTS";
  ContentPosition2[ContentPosition2["CHAT_IMAGE"] = 4] = "CHAT_IMAGE";
  ContentPosition2[ContentPosition2["AFTER_IMAGE"] = 5] = "AFTER_IMAGE";
  ContentPosition2[ContentPosition2["BEFORE_MARKDOWN"] = 6] = "BEFORE_MARKDOWN";
  ContentPosition2[ContentPosition2["MARKDOWN"] = 7] = "MARKDOWN";
  ContentPosition2[ContentPosition2["AFTER_MARKDOWN"] = 8] = "AFTER_MARKDOWN";
  ContentPosition2[ContentPosition2["CHAT_DOCUMENT_FILES"] = 9] = "CHAT_DOCUMENT_FILES";
  ContentPosition2[ContentPosition2["AFTER_DOCUMENT_FILES"] = 10] = "AFTER_DOCUMENT_FILES";
  ContentPosition2[ContentPosition2["CHAT_SOURCES"] = 11] = "CHAT_SOURCES";
  ContentPosition2[ContentPosition2["AFTER_SOURCES"] = 12] = "AFTER_SOURCES";
  ContentPosition2[ContentPosition2["SUGGESTED_QUESTIONS"] = 13] = "SUGGESTED_QUESTIONS";
  ContentPosition2[ContentPosition2["AFTER_SUGGESTED_QUESTIONS"] = 14] = "AFTER_SUGGESTED_QUESTIONS";
  ContentPosition2[ContentPosition2["BOTTOM"] = 9999] = "BOTTOM";
  return ContentPosition2;
})(ContentPosition || {});
var chatMessageContext = (0, import_react3.createContext)(null);
var ChatMessageProvider = chatMessageContext.Provider;
var useChatMessage = () => {
  const context = (0, import_react3.useContext)(chatMessageContext);
  if (!context)
    throw new Error("useChatMessage must be used within a ChatMessageProvider");
  return context;
};
function ChatMessage(props) {
  var _a;
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ChatMessageAvatar, {}),
    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ChatMessageContent, { isLoading: props.isLoading, append: props.append }),
    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ChatMessageActions, {})
  ] });
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    ChatMessageProvider,
    {
      value: { message: props.message, isLast: props.isLast },
      children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: cn("group flex gap-4 p-3", props.className), children })
    }
  );
}
function ChatMessageAvatar(props) {
  var _a, _b;
  const { message } = useChatMessage();
  const roleIconMap = {
    user: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_lucide_react.User2, { className: "h-4 w-4" }),
    assistant: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_lucide_react.Bot, { className: "h-4 w-4" })
  };
  const children = (_b = (_a = props.children) != null ? _a : roleIconMap[message.role]) != null ? _b : /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_lucide_react.MessageCircle, { className: "h-4 w-4" });
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "bg-background flex h-8 w-8 shrink-0 select-none items-center justify-center border", children });
}
function ChatMessageContent(props) {
  var _a, _b;
  const { message: defaultMessage, isLast } = useChatMessage();
  const message = (_a = props.message) != null ? _a : defaultMessage;
  const annotations = message.annotations;
  const contents = (0, import_react3.useMemo)(() => {
    var _a2, _b2;
    const displayMap = __spreadValues({
      [0 /* CHAT_EVENTS */]: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
        EventAnnotations,
        {
          message,
          showLoading: (_a2 = isLast && props.isLoading) != null ? _a2 : false
        }
      ),
      [2 /* CHAT_AGENT_EVENTS */]: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(AgentEventAnnotations, { message }),
      [4 /* CHAT_IMAGE */]: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ImageAnnotations, { message }),
      [7 /* MARKDOWN */]: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
        import_widgets3.Markdown,
        {
          content: message.content,
          sources: annotations ? getSourceAnnotationData(annotations)[0] : void 0
        }
      ),
      [9 /* CHAT_DOCUMENT_FILES */]: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(DocumentFileAnnotations, { message }),
      [11 /* CHAT_SOURCES */]: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(SourceAnnotations, { message })
    }, isLast && props.append && {
      // show suggested questions only on the last message
      [13 /* SUGGESTED_QUESTIONS */]: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
        SuggestedQuestionsAnnotations,
        {
          message,
          append: props.append
        }
      )
    });
    (_b2 = props.content) == null ? void 0 : _b2.forEach((content) => {
      displayMap[content.position] = content.component;
    });
    return Object.entries(displayMap).map(([position, component]) => ({
      position: parseInt(position),
      component
    }));
  }, [
    annotations,
    isLast,
    message,
    props.append,
    props.content,
    props.isLoading
  ]);
  const children = (_b = props.children) != null ? _b : /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: contents.sort((a, b) => a.position - b.position).map((content, index) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_react3.Fragment, { children: content.component }, index)) });
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: cn("flex min-w-0 flex-1 flex-col gap-4", props.className), children });
}
function ChatMessageActions(props) {
  var _a;
  const { isCopied, copyToClipboard } = useCopyToClipboard({ timeout: 2e3 });
  const { message } = useChatMessage();
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    Button,
    {
      onClick: () => copyToClipboard(message.content),
      size: "icon",
      variant: "ghost",
      className: "h-8 w-8",
      children: isCopied ? /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_lucide_react.Check, { className: "h-4 w-4" }) : /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_lucide_react.Copy, { className: "h-4 w-4" })
    }
  );
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    "div",
    {
      className: cn(
        "flex shrink-0 flex-col gap-2 opacity-0 group-hover:opacity-100",
        props.className
      ),
      children
    }
  );
}
var PrimiviteChatMessage = (0, import_react3.memo)(ChatMessage, (prevProps, nextProps) => {
  return !nextProps.isLast && prevProps.isLast === nextProps.isLast && prevProps.message === nextProps.message;
});
PrimiviteChatMessage.Avatar = ChatMessageAvatar;
PrimiviteChatMessage.Content = ChatMessageContent;
PrimiviteChatMessage.Actions = ChatMessageActions;
var chat_message_default = PrimiviteChatMessage;

// src/chat/chat-messages.tsx
var import_jsx_runtime7 = require("react/jsx-runtime");
var chatMessagesContext = (0, import_react4.createContext)(null);
var ChatMessagesProvider = chatMessagesContext.Provider;
var useChatMessages = () => {
  const context = (0, import_react4.useContext)(chatMessagesContext);
  if (!context) {
    throw new Error(
      "useChatMessages must be used within a ChatMessagesProvider"
    );
  }
  return context;
};
function ChatMessages(props) {
  var _a;
  const { messages, reload, stop, isLoading } = useChatUI();
  const messageLength = messages.length;
  const lastMessage = messages[messageLength - 1];
  const isLastMessageFromAssistant = messageLength > 0 && (lastMessage == null ? void 0 : lastMessage.role) !== "user";
  const showReload = reload && !isLoading && isLastMessageFromAssistant;
  const showStop = stop && isLoading;
  const isPending = isLoading && !isLastMessageFromAssistant;
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(ChatMessagesList, {}),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(ChatActions, {})
  ] });
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    ChatMessagesProvider,
    {
      value: { isPending, showReload, showStop, lastMessage, messageLength },
      children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        "div",
        {
          className: cn(
            "bg-background relative flex min-h-0 flex-1 flex-col space-y-6 p-4",
            props.className
          ),
          children
        }
      )
    }
  );
}
function ChatMessagesList(props) {
  var _a;
  const scrollableChatContainerRef = (0, import_react4.useRef)(null);
  const { messages, isLoading, append } = useChatUI();
  const { lastMessage, messageLength } = useChatMessages();
  const scrollToBottom = () => {
    if (scrollableChatContainerRef.current) {
      scrollableChatContainerRef.current.scrollTop = scrollableChatContainerRef.current.scrollHeight;
    }
  };
  (0, import_react4.useEffect)(() => {
    scrollToBottom();
  }, [messageLength, lastMessage]);
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
    messages.map((message, index) => {
      return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        chat_message_default,
        {
          message,
          isLast: index === messageLength - 1,
          isLoading,
          append
        },
        index
      );
    }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(ChatMessagesLoading, {})
  ] });
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    "div",
    {
      className: cn(
        "flex min-h-0 flex-1 flex-col gap-5 overflow-auto",
        props.className
      ),
      ref: scrollableChatContainerRef,
      children
    }
  );
}
function ChatMessagesLoading(props) {
  var _a;
  const { isPending } = useChatMessages();
  if (!isPending) return null;
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_lucide_react2.Loader2, { className: "h-4 w-4 animate-spin" });
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    "div",
    {
      className: cn("flex items-center justify-center pt-4", props.className),
      children
    }
  );
}
function ChatActions(props) {
  var _a;
  const { reload, stop, requestData } = useChatUI();
  const { showReload, showStop } = useChatMessages();
  if (!showStop && !showReload) return null;
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
    showStop && /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(Button, { variant: "outline", size: "sm", onClick: stop, children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_lucide_react2.PauseCircle, { className: "mr-2 h-4 w-4" }),
      "Stop generating"
    ] }),
    showReload && /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
      Button,
      {
        variant: "outline",
        size: "sm",
        onClick: () => reload == null ? void 0 : reload({ data: requestData }),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_lucide_react2.RefreshCw, { className: "mr-2 h-4 w-4" }),
          "Regenerate"
        ]
      }
    )
  ] });
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { className: cn("flex justify-end gap-4", props.className), children });
}
ChatMessages.List = ChatMessagesList;
ChatMessages.Loading = ChatMessagesLoading;
ChatMessages.Actions = ChatActions;
var chat_messages_default = ChatMessages;

// src/chat/chat-section.tsx
var import_jsx_runtime8 = require("react/jsx-runtime");
function ChatSection(props) {
  var _a;
  const { handler, className } = props;
  const [requestData, setRequestData] = (0, import_react5.useState)();
  const children = (_a = props.children) != null ? _a : /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(chat_messages_default, {}),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(chat_input_default, {})
  ] });
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(ChatProvider, { value: __spreadProps(__spreadValues({}, handler), { requestData, setRequestData }), children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: cn("flex flex-col gap-4", className), children }) });
}

// src/hook/use-file.tsx
var import_react6 = require("react");
var docMineTypeMap = {
  "text/csv": "csv",
  "application/pdf": "pdf",
  "text/plain": "txt",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "docx"
};
function useFile({ uploadAPI }) {
  const [imageUrl, setImageUrl] = (0, import_react6.useState)(null);
  const [files, setFiles] = (0, import_react6.useState)([]);
  const addDoc = (file) => {
    const existedFile = files.find((f) => f.id === file.id);
    if (!existedFile) {
      setFiles((prev) => [...prev, file]);
      return true;
    }
    return false;
  };
  const removeDoc = (file) => {
    setFiles((prev) => prev.filter((f) => f.id !== file.id));
  };
  const reset = () => {
    imageUrl && setImageUrl(null);
    files.length && setFiles([]);
  };
  const uploadContent = (_0, ..._1) => __async(this, [_0, ..._1], function* (file, requestParams = {}) {
    const base64 = yield readContent({ file, asUrl: true });
    const response = yield fetch(uploadAPI, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(__spreadProps(__spreadValues({}, requestParams), {
        base64,
        name: file.name
      }))
    });
    if (!response.ok) throw new Error("Failed to upload document.");
    return yield response.json();
  });
  const getAnnotations = () => {
    const annotations = [];
    if (imageUrl) {
      annotations.push({
        type: "image",
        data: { url: imageUrl }
      });
    }
    if (files.length > 0) {
      annotations.push({
        type: "document_file",
        data: { files }
      });
    }
    return annotations;
  };
  const readContent = (input) => __async(this, null, function* () {
    const { file, asUrl } = input;
    const content = yield new Promise((resolve, reject) => {
      const reader = new FileReader();
      if (asUrl) {
        reader.readAsDataURL(file);
      } else {
        reader.readAsText(file);
      }
      reader.onload = () => resolve(reader.result);
      reader.onerror = (error) => reject(error);
    });
    return content;
  });
  const uploadFile = (_0, ..._1) => __async(this, [_0, ..._1], function* (file, requestParams = {}) {
    if (file.type.startsWith("image/")) {
      const base64 = yield readContent({ file, asUrl: true });
      return setImageUrl(base64);
    }
    const filetype = docMineTypeMap[file.type];
    if (!filetype) throw new Error("Unsupported document type.");
    const newDoc = yield uploadContent(file, requestParams);
    return addDoc(newDoc);
  });
  return {
    imageUrl,
    setImageUrl,
    files,
    removeDoc,
    reset,
    getAnnotations,
    uploadFile
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ChatInput,
  ChatMessage,
  ChatMessages,
  ChatSection,
  ContentPosition,
  DOCUMENT_FILE_TYPES,
  MessageAnnotationType,
  getAnnotationData,
  getSourceAnnotationData,
  useChatInput,
  useChatMessage,
  useChatMessages,
  useChatUI,
  useFile
});
//# sourceMappingURL=index.cjs.map